[{"categories":["Tips"],"content":"Kubernetes 中优雅停止 Pod ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:1:0","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"优雅停止 就像我们关机时一样，系统会完成一些清理操作之后再关闭，称之为优雅停止。 如果我们直接拔掉电源（硬中止），那么系统中的一些任务和操作将会来不及进行处理，有时会导致未知的问题。 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:1:1","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"K8s 中停止 Pod 的逻辑 当 Pod 被删除，会变为 Terminating 状态，Pod metadata 中 deletionTimestamp 字段会被标记删除时间 Kube-proxy 在周期内更新转发规则，将 Pod 从 service 的 endpoint 列表中删除，新的流量将不会转发到该 Pod kubelet 开始销毁 pod 如果 pod spec 中设置了 preStop hook，将会执行 发送 SIGTERM 信号给容器内主进程，通知容器进行优雅中止 等待 container 中的主进程完全停止，如果在 terminationGracePeriodSeconds 内（默认30s）还未停止，就发送 SIGKILL信号强制中止 所有容器进程终止，清理 Pod 资源 通知 ApiServer pod 销毁完成。 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:1:2","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"使用 preStop 字段 可以使用 preStop 字段来执行自定义的优雅停止逻辑 参考 Kubernetes API 文档 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:1:3","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"Kubernetes 健康检查 K8s 目前支持三种健康检查： ReadinessProbe 就绪检查 只有在就绪检查成功的前提下，才会接收流量，否则不会接收流量 LivenessProbe 存活检查 如果存活检查不成功，会自动重启容器 startupProbe 启动检查 让存活检查和就绪检查的开始探测时间延后，也就是说只有在启动检查成功的前提下，才会执行就绪检查或存活检查 注意 首选 HTTP 探测 备选脚本探测 尽量避免 TCP 探测 因为只要端口能够响应 TCP SYN 包，TCP 检测结果都为 true ，当程序死锁时，不会影响端口，所以可能检测结果为 true，但实际上业务已经不健康了。 所有提供服务的 container 都要加上 ReadinessProbe 谨慎使用 LivenessProbe ，如果非用不可，则应该尽量放宽探测条件 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:2:0","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"合理设置 Request 和 Limit 所有容器都应该设置 request request 的值并不是指给容器实际分配的资源大小，而是用于给调度器用来判断每个节点上可分配资源还有多少。 通过节点总资源减去各容器定义的 request 之和，可以计算出节点上还有多少资源可供分配，从而做出合理的调度决策。 如果当前节点可供分配资源小于被调度的容器的 request ，则不会调度到该节点。如果无法合理调度，可能会出现节点资源利用不均的结果。 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:3:0","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"重要的线上应用应该如何设置 节点资源不足时，会触发自动驱逐，会根据优先级删除 Pod 以释放资源让节点自愈。 没有设置 request，limit 的 Pod 优先级最低，其次是 request 不等于 limit 的 Pod ， request 等于 limit 的 Pod 优先级最高，不容易被驱逐。 所以建议将重要的线上应用的 request 和 limit 设置为一致的值。 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:3:1","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"K8s 中权限控制的自动化实现 在 cluster 创建时， 创建自定义的 role，比如 namespace-creator，namespace-creator 定义用户可操作的对象和对应的读写操作。 创建自定义的 namespace admission controller 当 namespace 创建请求被处理时，获取当前用户信心并 annotate 到 namespace 创建 RBAC controller Watch namespace 的创建事件 获取当前 namespace 的创建者信息 在当前 namespace 创建 rolebinding 对象，并将 namespace-creator 角色和用户绑定 ","date":"2022-08-22","objectID":"/kubernetes-tutorial/:4:0","tags":["Kubernetes"],"title":"Kubernetes 生产实践 Tips","uri":"/kubernetes-tutorial/"},{"categories":["Tips"],"content":"Gin 框架 ","date":"2022-08-01","objectID":"/gin/:0:0","tags":["Go","Gin"],"title":"Gin 框架知识汇总","uri":"/gin/"},{"categories":["Tips"],"content":"## 安装 要求 Go 1.13 及以上版本 安装 go get -u github.com/gin-gonic/gin 引入 import \"github.com/gin-gonic/gin\" ","date":"2022-08-01","objectID":"/gin/:1:0","tags":["Go","Gin"],"title":"Gin 框架知识汇总","uri":"/gin/"},{"categories":["Tips"],"content":"基本使用 初始化 r := gin.Default() 路由处理 基本操作 r.GET(relative Path，handler) r.POST(relative Path，handler) r.PUT(relative Path，handler) r.DELETE(relative Path，handler) 路由分组 apiv1 := r.Group(relative Path) { apiv1.GET(relative Path，handler) apiv1.POST(relative Path，handler) apiv1.PUT(relative Path，handler) apiv1.DELETE(relative Path，handler) } ","date":"2022-08-01","objectID":"/gin/:2:0","tags":["Go","Gin"],"title":"Gin 框架知识汇总","uri":"/gin/"},{"categories":["Tips"],"content":"容器技术的代表– Docker 的一些知识点记录。 TODO ","date":"2022-07-28","objectID":"/docker/:0:0","tags":["Docker","云原生"],"title":"docker 的一点小知识","uri":"/docker/"},{"categories":["Tips"],"content":"记录 Go 常用的一些库相关知识。 ","date":"2022-07-22","objectID":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/:0:0","tags":["Go"],"title":"Go 常用库知识","uri":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/"},{"categories":["Tips"],"content":"time ","date":"2022-07-22","objectID":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/:1:0","tags":["Go"],"title":"Go 常用库知识","uri":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/"},{"categories":["Tips"],"content":"time.NewTicker定时器 NewTicker 会返回一个新的 Ticker ticker.C 该 Ticker 会包含一个通道字段，并会每隔时间断 d 就向该通道发送当前时间 ticker.Reset 重置计时器，使 t 重新计时 ticker.Stop 停止计时器 示例代码 package main import ( \"fmt\" \"time\" ) func main() { //创建一个周期性的定时器 ticker := time.NewTicker(3 * time.Second) fmt.Println(\"当前时间为:\", time.Now()) go func() { for { //从定时器中获取数据 t := \u003c-ticker.C fmt.Println(\"当前时间为:\", t) } }() for { time.Sleep(time.Second * 1) } } ","date":"2022-07-22","objectID":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/:1:1","tags":["Go"],"title":"Go 常用库知识","uri":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/"},{"categories":["Tips"],"content":"Casbin casbin 是一个强大、高效的访问控制库。 安装方式 版本 v2 go get github.com/casbin/casbin/v2 使用方式 casbin 将访问控制模型抽象在基于 PERM 模型的配置文件中。如果需要改变授权机制，只需要更改配置文件即可。 配置文件分为 model.conf 和 policy.csv policy 定义具体的规则 request 是对访问请求的抽象，它的参数与 e.Enforce() 函数的参数一一对应 matcher 用于将请求和定义的规则一一匹配，生成匹配结果 effect 根据匹配结果进行结果汇总，用于决定允许还是拒绝这次请求 示例1(ACL模型) model.conf [request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [matchers] m = r.sub == p.sub \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act [policy_effect] e = some(where (p.eft == allow)) policy.csv p, dajun, data1, read p, lizi, data2, write main.go package main import ( \"fmt\" \"log\" \"github.com/casbin/casbin/v2\" ) func check(e *casbin.Enforcer, sub, obj, act string) { ok, _ := e.Enforce(sub, obj, act) if ok { fmt.Printf(\"%s CAN %s %s\\n\", sub, act, obj) } else { fmt.Printf(\"%s CANNOT %s %s\\n\", sub, act, obj) } } func main() { e, err := casbin.NewEnforcer(\"./model.conf\", \"./policy.csv\") if err != nil { log.Fatalf(\"NewEnforecer failed:%v\\n\", err) } check(e, \"dajun\", \"data1\", \"read\") check(e, \"lizi\", \"data2\", \"write\") check(e, \"dajun\", \"data1\", \"write\") check(e, \"dajun\", \"data2\", \"read\") } Result $ go run main.go dajun CAN read data1 lizi CAN write data2 dajun CANNOT write data1 dajun CANNOT read data2 示例2（RBAC） 在 casbin 中使用 RBAC 模型需要在模型文件中添加 role_definition 模块,同时修改 matchers 模块： [role_definition] g = _, _ [matchers] m = g(r.sub, p.sub) \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act policy.csv p, admin, data, read p, admin, data, write p, developer, data, read g, dajun, admin g, lizi, developer main.go package main import ( \"fmt\" \"log\" \"github.com/casbin/casbin/v2\" ) func check(e *casbin.Enforcer, sub, obj, act string) { ok, _ := e.Enforce(sub, obj, act) if ok { fmt.Printf(\"%s CAN %s %s\\n\", sub, act, obj) } else { fmt.Printf(\"%s CANNOT %s %s\\n\", sub, act, obj) } } func main() { e, err := casbin.NewEnforcer(\"./model.conf\", \"./policy.csv\") if err != nil { log.Fatalf(\"NewEnforecer failed:%v\\n\", err) } check(e, \"dajun\", \"data\", \"read\") check(e, \"dajun\", \"data\", \"write\") check(e, \"lizi\", \"data\", \"read\") check(e, \"lizi\", \"data\", \"write\") } Result dajun CAN read data dajun CAN write data lizi CAN read data lizi CANNOT write data ","date":"2022-07-22","objectID":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/:2:0","tags":["Go"],"title":"Go 常用库知识","uri":"/go%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9F%A5%E8%AF%86/"},{"categories":["Guide"],"content":"cerebro 是一款开源的用于管理 Elasticsearch 的 Web 端管理工具。 ","date":"2022-06-24","objectID":"/cerebro/:0:0","tags":["cerebro","Elasticsearch"],"title":"Cerebro 的安装","uri":"/cerebro/"},{"categories":["Guide"],"content":"工具介绍 项目地址 https://github.com/lmenezes/cerebro 项目依赖 Java 11 及以上版本 ","date":"2022-06-24","objectID":"/cerebro/:1:0","tags":["cerebro","Elasticsearch"],"title":"Cerebro 的安装","uri":"/cerebro/"},{"categories":["Guide"],"content":"安装 安装方式 软件包安装 下载地址：https://github.com/lmenezes/cerebro/releases Docker（推荐） 执行命令 docker run --name cerebro -d -p 9000:9000 lmenezes/cerebro:0.8.4 ","date":"2022-06-24","objectID":"/cerebro/:2:0","tags":["cerebro","Elasticsearch"],"title":"Cerebro 的安装","uri":"/cerebro/"},{"categories":["Guide"],"content":"简单记录下 Elasticsearch 的安装和配置","date":"2022-06-01","objectID":"/elasticsearch00/","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"简单记录下 Elasticsearch 的安装和配置。 ","date":"2022-06-01","objectID":"/elasticsearch00/:0:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"获取安装包 官网地址 https://www.elastic.co/cn/elasticsearch/ 下载方式 软件包下载 包管理器下载 使用版本 V8.2.2 ","date":"2022-06-01","objectID":"/elasticsearch00/:1:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"Elasticsearch 的文件目录结构 bin 脚本文件，包括启动ES、安装插件、运行统计数据等 config elasticsearch.yml 集群配置文件：user、role based等相关配置 JDK Java运行环境 data path.data 数据文件 lib Java类库 logs path.log 日志文件 modules 包含所有ES模块 plugins 包含所有已安装插件 ","date":"2022-06-01","objectID":"/elasticsearch00/:2:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"运行 Elasticsearch 下载并解压缩 Elasticsearch 创建 es 用户并赋予权限（ES 默认不能使用 root 用户启动） useradd es passwd es chown -R es:es elasticsearch-8.2.2/ chmod 770 elasticsearch-8.2.2/ 使用 es 用户运行 bin/elasticsearch 运行 curl http://localhost:9200/ ES同时也支持使用 Docker 启动 docker run --name elasticsearch -d -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -e \"discovery.type=single-node\" -p 9200:9200 -p 9300:9300 elasticsearch:8.2.2 ","date":"2022-06-01","objectID":"/elasticsearch00/:3:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"JVM配置 ","date":"2022-06-01","objectID":"/elasticsearch00/:4:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"修改 JVM config/jvm.options 建议 Xms 和 Xmx 设置成一样 Xmx 不要超过机器内存的50% 不要超过 30GB ","date":"2022-06-01","objectID":"/elasticsearch00/:4:1","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"其他配置 ","date":"2022-06-01","objectID":"/elasticsearch00/:5:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"如果需要外部能够访问，则需要修改 network.host 在 config/elasticsearch.yml 中修改 network.host 字段内容为 0.0.0.0 ，并去掉注释标记 ","date":"2022-06-01","objectID":"/elasticsearch00/:5:1","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"如果启动后访问时报错：ERR_EMPTY_RESPONSE 这是因为启动后增添了一些认证配置信息 需要将 xpack.security.enabled，xpack.security.enrollment.enabled 修改为 false 来关闭 ssl 认证 ","date":"2022-06-01","objectID":"/elasticsearch00/:5:2","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"以多实例方式运行Elasticsearch 需要在 config/elasticsearch.yml 中设置 cluster.initial_master_nodes 字段值为 myecs （这里的 myecs 是第一个节点的名称） 执行如下命令即可： bin/elasticsearch -E node.name=myecs -E cluster.name=mycluster -E path.data=myecs_data -d bin/elasticsearch -E node.name=node1 -E cluster.name=mycluster -E path.data=node1_data -d bin/elasticsearch -E node.name=node2 -E cluster.name=mycluster -E path.data=node2_data -d 关闭进程： ps -ef|grep elasticsearch kill -9 [pid] ","date":"2022-06-01","objectID":"/elasticsearch00/:6:0","tags":["Elasticsearch"],"title":"Elasticsearch 的安装和配置方法","uri":"/elasticsearch00/"},{"categories":["Guide"],"content":"Typora","date":"2022-02-05","objectID":"/image-hub-based-on-typora/","tags":["blog","PicGo","Typora","OSS"],"title":"在 Typora 中基于阿里云 OSS + PicGo 搭建图床 ","uri":"/image-hub-based-on-typora/"},{"categories":["Guide"],"content":" 图床可以理解成是一个在互联网上专门用来存放图片的场所，每一张图片都可以通过 URL 被其他人使用 ","date":"2022-02-05","objectID":"/image-hub-based-on-typora/:0:0","tags":["blog","PicGo","Typora","OSS"],"title":"在 Typora 中基于阿里云 OSS + PicGo 搭建图床 ","uri":"/image-hub-based-on-typora/"},{"categories":["Guide"],"content":"必备物料 Typora PicGo 阿里云 OSS 服务 ","date":"2022-02-05","objectID":"/image-hub-based-on-typora/:0:1","tags":["blog","PicGo","Typora","OSS"],"title":"在 Typora 中基于阿里云 OSS + PicGo 搭建图床 ","uri":"/image-hub-based-on-typora/"},{"categories":["Guide"],"content":"开通阿里云 OSS 服务 登录阿里云官网，在产品中搜索 OSS，开通对象存储 OSS 服务 进入管理控制台，购买对象存储 OSS 资源包 根据个人情况选择对应套餐即可。这里我选择一年时长，其余都保持默认配置。 创建 Bucket 进入控制台，选择左侧的 Bucket 列表，点击 创建 Bucket 填写各选项，点击确定即可 创建用户 AccessKey 点击右上角头像，选择 AccessKey 管理 创建好 AccessKey 后妥善保存 ","date":"2022-02-05","objectID":"/image-hub-based-on-typora/:0:2","tags":["blog","PicGo","Typora","OSS"],"title":"在 Typora 中基于阿里云 OSS + PicGo 搭建图床 ","uri":"/image-hub-based-on-typora/"},{"categories":["Guide"],"content":"PicGo 打开 Typora 设置-通用，勾选 开启调试模式 按下图设置图像选项 下载 PicGo 打开 PicGo ，选择图床设置-阿里云OSS进行配置 验证 打开 Typora 的偏好设置，点击图像- 验证图片上传选项，查看返回信息。 可以看到，PicGo 上传图片到阿里云 OSS 的 Bucket 中是成功的，设置完成。 ","date":"2022-02-05","objectID":"/image-hub-based-on-typora/:0:3","tags":["blog","PicGo","Typora","OSS"],"title":"在 Typora 中基于阿里云 OSS + PicGo 搭建图床 ","uri":"/image-hub-based-on-typora/"},{"categories":["Guide"],"content":"Hugo 是采用 Go 语言开发的一种开源网站搭建框架，具有速度快、灵活、可扩展性强的特点。","date":"2021-12-01","objectID":"/hugo-based-blog-guide/","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":" 什么是 hugo ？ Hugo 是采用 Go 语言开发的一种开源网站搭建框架，具有速度快、灵活、可扩展性强的特点。 主要内容 博客搭建 博客美化 博客功能扩展 博文发布的解决方案 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:0:0","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"博客搭建 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:1:0","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"需准备 Git Git 的安装方法请参阅这里 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:1:1","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"Step 1：安装 Hugo 本示例基于 MacOS ，其他操作系统下 Hugo 的安装方法请参阅 安装 打开 Terminal ，使用 homebraw 安装： brew install hugo 验证安装是否成功，请执行： hugo version 返回结果如下则表明安装成功。 extended 表明 Hugo 版本为扩展版本，支持 Sass / Scss , 更多信息，请参考 Sass ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:1:2","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"Step 2：创建一个新的博客项目 准备一个 Hugo 的工作目录，在该目录下执行： hugo new site \u003c博客项目名\u003e 出现如下信息则证明创建成功。 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:1:3","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"Step 3：安装主题 进入该博客项目目录，目录结构如下： archetypes content data layouts static themes config.toml 如何添加主题呢？ 本次示例选择的是 LoveIt 主题 首先，从 Github 下载主题并将其添加到博客项目目录的 theme 目录中： cd mi2mcn git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 接下来，需要配置 config.toml 文件， 我们选择直接拷贝 LoveIt 主题中的实例网站的配置文件： cp -p themes/LoveIt/exampleSite/config.toml . 然后将配置文件中的 themesDir 项更改为如下内容： # 主题目录 themesDir = \"./themes\" 最后，执行如下命令，在本地开启一个 Web 服务器： hugo server -D 根据提示信息，在本地浏览器中访问 http://localhost:1313/ ，返回如下页面则代表搭建成功。 这里的图片显示有误，是因为我们没有修改配置文件中默认的图片路径，后续根据个人情况修改即可。 添加文章 所有文章都在 content/post 目录下 使用命令添加 hugo new posts/my-first-post.md 直接在 content/posts 目录下添加 markdown 文件即可 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:1:4","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"博客美化 每个主题的配置都是有差异的，本示例以 LoveIt 主题为基准进行个性化设置和美化。 配置文件 LoveIt 主题的配置文件主要分为以下几个部分： # baseURL # 主题目录 # 网站通用设置： 标题、语言设置、作者设置等 # 网站导航栏设置 # 网站页面底部设置 # 网站主页设置：主页信息、主页文章列表、主页社交信息等 # 网站分区设置 # 网站列表设置 # 网站APP端设置 # 网站搜索设置 # 文章页面设置 # 文章评论设置 # 第三方库配置 # 页面 SEO 配置 # TypeIt 配置 # 网站分析配置 # CDN 配置 # hugo 解析文档配置 # 网站地图配置 ## 支持多语言 主页美化 在站点目录下的 config.toml 中按需修改即可。 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:2:0","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"博客功能扩展 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:3:0","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"全文搜索 搜索功能我们使用第三方的 algolia 实现 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:3:1","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"评论功能 评论功能我们使用第三方的 valine 实现 ","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:3:2","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"博客发布方案 github pages 腾讯云静态网站托管 Netlify部署","date":"2021-12-01","objectID":"/hugo-based-blog-guide/:4:0","tags":["blog","Hugo"],"title":"基于 Hugo 的个人博客体系不完全指南","uri":"/hugo-based-blog-guide/"},{"categories":["Guide"],"content":"ElasticSearch 负责储存日志信息，Grafana 负责对日志信息进行监控和告警","date":"2021-02-01","objectID":"/es-grafana-based-log-alert/","tags":["Grafana","Elasticsearch"],"title":"基于 Grafana 和 Elasticsearch 对日志信息进行监控告警","uri":"/es-grafana-based-log-alert/"},{"categories":["Guide"],"content":" 在公司环境中，除了日志的存储和可视化需求外，我们常常需要对日志信息进行监控，关注某些报错信息，目前最常用的日志架构是 ELK ，即 Elasticsearch 、LogStash 和 Kibana 的组合，其中 LogStash 负责日志的采集和过滤，ElasticSearch 负责日志的存储，而 Kibana 则负责日志的可视化，而日志的告警则可以通过 Grafana 来实现。 Grafana 是一个开源的数据可视化组件，经常被用作时间序列数据可视化和分析。它支持很多数据源，这其中包括 Prometheus 、 OpenTSDB 、Graphite 、InfluxDB 、Elasticsearch 等等。Grafana 支持从数据源中查询数据，支持组合多个不同数据源中的数据到一个展示仪表盘上，同时最新的 Grafana 也继承了告警组件，可以实现对数据源信息的监控和告警。 ","date":"2021-02-01","objectID":"/es-grafana-based-log-alert/:0:0","tags":["Grafana","Elasticsearch"],"title":"基于 Grafana 和 Elasticsearch 对日志信息进行监控告警","uri":"/es-grafana-based-log-alert/"},{"categories":["Guide"],"content":"添加 Elasticsearch 数据源 step 1：登录 Grafana 登录你的 Grafana 管理界面 step 2：添加数据源 点击左侧 Configuration （小齿轮），选择 Data Sources: 点击右上角 Add data source: 选择 Logging \u0026 document database 中的 Elasticsearch： 填写对应信息，然后点击 Save \u0026 Test: 返回如下信息则代表添加数据源成功： step 3：添加告警组件 点击左侧 Alerting（铃铛），选择 Notification channels: 点击 New channel： 填写以下信息，点击 Save 保存即可： step 4：添加仪表盘 点击右侧的 Create（“+”号），选择 Dashboard: 点击 Add new panel: 选择正确的数据源： 填写查询条件： 点击 Alert 下的 Create Alert: 设置告警策略： 设置告警信息的接受者和告警提示信息： ","date":"2021-02-01","objectID":"/es-grafana-based-log-alert/:1:0","tags":["Grafana","Elasticsearch"],"title":"基于 Grafana 和 Elasticsearch 对日志信息进行监控告警","uri":"/es-grafana-based-log-alert/"},{"categories":null,"content":"关于","date":"2020-01-02","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"}]